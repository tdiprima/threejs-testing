<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>object picking</title>
  <!-- http://soledadpenades.com/articles/three-js-tutorials/object-picking/ -->
  <!-- https://stackoverflow.com/questions/27690441/three-js-better-way-of-adding-multiple-cubes-to-a-scene -->

  <script src="three.min.js"></script>
  <script src="TrackballControls.js"></script>

  <!-- <script src="/build/three.min.js"></script>
  <script src="/jsm/controls/TrackballControls.js"></script> -->

  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      overflow: hidden;
    }
    h1 {
      font-family: Helvetica, Arial, sans, serif;
      font-size: 1.5rem;
      font-weight: normal;
      position: relative;
      z-index: 10;
      text-align: center;
      text-shadow: 1px 1px 1px #fff;
    }
    a {
      color: #00a;
    }
    #container {
      position: absolute;
      z-index: 0;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

<h1>object picking with three.js - <a href="http://soledadpenades.com/articles/three-js-tutorials/object-picking/">tutorial</a></h1>
<div id="container"></div>

<script>
  window.onload = function() {
    let container = document.getElementById('container'),
      containerWidth,
      containerHeight,
      renderer,
      scene,
      camera,
      cubes,
      geom,
      range = 50,
      mouseVector,
      axes,
      controls;

    containerWidth = container.clientWidth;
    containerHeight = container.clientHeight;

    // Set up renderer, scene and camera
    renderer = new THREE.CanvasRenderer();
    renderer.setSize(containerWidth, containerHeight);
    container.appendChild(renderer.domElement);

    renderer.setClearColorHex(0xeeeedd, 1.0);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 1, 10000);
    camera.position.set(0, 0, range * 2);
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    // Add some cubes to the scene
    geom = new THREE.CubeGeometry(5, 5, 5);

    cubes = new THREE.Object3D();
    scene.add(cubes);

    // Note! Adding multiple cubes into an Object3D
    // instead of adding each cube separately into the scene.
    for (let i = 0; i < 100; i++) {
      let grayness = Math.random() * 0.5 + 0.25;
      let mat = new THREE.MeshBasicMaterial();
      let cube = new THREE.Mesh(geom, mat);
      mat.color.setRGB(grayness, grayness, grayness);
      cube.position.set(range * (0.5 - Math.random()), range * (0.5 - Math.random()), range * (0.5 - Math.random()));
      cube.rotation.set(Math.random(), Math.random(), Math.random()).multiplyScalar(2 * Math.PI);
      cube.grayness = grayness;
      cubes.add(cube);
    }

    // Axes
    axes = buildAxes();
    scene.add(axes);

    // Picking stuff
    projector = new THREE.Projector();
    mouseVector = new THREE.Vector3();

    // User interaction
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('resize', onWindowResize, false);

    controls = new THREE.TrackballControls(camera);
    controls.zoomSpeed = 0.1;

    // And go!
    animate();

    function onMouseMove(e) {
      mouseVector.x = 2 * (e.clientX / containerWidth) - 1;
      mouseVector.y = 1 - 2 * (e.clientY / containerHeight);

      let raycaster = projector.pickingRay(mouseVector.clone(), camera);
      let intersects = raycaster.intersectObjects(cubes.children);

      cubes.children.forEach(cube => {
        cube.material.color.setRGB(cube.grayness, cube.grayness, cube.grayness);
      });

      for (let i = 0; i < intersects.length; i++) {
        let intersection = intersects[i];
        let obj = intersection.object;

        obj.material.color.setRGB(1.0 - i / intersects.length, 0, 0);
      }
    }

    function onWindowResize(e) {
      containerWidth = container.clientWidth;
      containerHeight = container.clientHeight;
      renderer.setSize(containerWidth, containerHeight);
      camera.aspect = containerWidth / containerHeight;
      camera.updateProjectionMatrix();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    /**
     * http://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/
     * @return {THREE.Object3D} - axes
     */
    function buildAxes() {
      let axes = new THREE.Object3D();

      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(100, 0, 0), 0xff0000, false)); // +X
      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(-100, 0, 0), 0x800000, true)); // -X
      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 100, 0), 0x00ff00, false)); // +Y
      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -100, 0), 0x008000, true)); // -Y
      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 100), 0x0000ff, false)); // +Z
      axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -100), 0x000080, true)); // -Z

      return axes;
    }

    /**
     * Build Axis
     *
     * @param {object} src - x, y, z coordinates
     * @param {object} dst - x, y, z coordinates
     * @param {number} colorHex
     * @param {boolean} dashed
     * @return {THREE.Line} - axis
     */
    function buildAxis(src, dst, colorHex, dashed) {
      let geom = new THREE.Geometry();
      let mat;

      if (dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 1, color: colorHex, dashSize: 5, gapSize: 5 });
      } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 1, color: colorHex });
      }

      geom.vertices.push(src.clone());
      geom.vertices.push(dst.clone());

      return new THREE.Line(geom, mat); // AXIS
    }

    console.log(`%cTHREE REV: ${THREE.REVISION}`, "color: #ccff00;");

  };
</script>
</body>
</html>
