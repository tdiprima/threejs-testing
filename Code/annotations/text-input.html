<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Text Input Example</title>
  <!-- todo: no matter what, it ends up mid-screen -->
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<input id="text-input" placeholder="Type your text here" type="text">
<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}
</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  // Import necessary modules from Three.js
  import * as THREE from "three";
  import { FontLoader } from "three/addons/loaders/FontLoader.js";
  import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

  // Initialize variables
  let scene, camera, renderer, mouse, raycaster;
  let textObjects = [];
  // let fontUrl = "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";
  let fontUrl = "helvetiker_regular.typeface.json";

  // Create a new text object
  function createTextObject(text, x, y) {
    const loader = new FontLoader();
    loader.load(fontUrl, function(font) {
      const geometry = new TextGeometry(text, {
        font: font,
        size: 5,
        height: 0.2
      });
      const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const textMesh = new THREE.Mesh(geometry, material);

      // Set the position based on the click coordinates
      textMesh.position.set(x, y, 0);
      scene.add(textMesh);
      console.log("%cposition", "color: #ccff00;", textMesh.position);
      textObjects.push(textMesh);
    });
  }

  function clean() {
    // https://stackoverflow.com/questions/30359830/how-do-i-clear-three-js-scene
    // while(scene.children.length > 0){
    //   scene.remove(scene.children[0]);
    // }
    // https://stackoverflow.com/questions/37762961/three-js-proper-removing-object-from-scene-still-reserved-in-heap/
    textObjects.forEach(function(v, i) {
      v.material.dispose();
      v.geometry.dispose();
      scene.remove(v);
    });
  }

  // Handle mouse click events
  function onClick(event) {
    // Clear canvas before drawing
    clean();

    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    const mouse = new THREE.Vector2(
      (x / canvas.clientWidth) * 2 - 1,
      -(y / canvas.clientHeight) * 2 + 1
    );

    raycaster.setFromCamera(mouse, camera);
    // const intersects = raycaster.intersectObjects(scene.children);
    // todo: OR -
    const intersects = raycaster.intersectObjects(textObjects);

    if (intersects.length === 0) {
      const textInput = document.getElementById("text-input");
      const text = textInput.value.trim();

      if (text !== "") {
        // console.log("%cmouse", "color: #ff00cc;", mouse);
        createTextObject(text, mouse.x, mouse.y);
        textInput.value = "";
      }
    }
  }

  // Initialize the scene, camera, and renderer
  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    mouse = new THREE.Vector2();
    raycaster = new THREE.Raycaster();

    document.addEventListener("click", onClick, false);
  }

  // Animate the scene
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }

  // Start the application
  init();
  animate();
</script>
</body>
</html>
