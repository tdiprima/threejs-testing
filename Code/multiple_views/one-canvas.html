<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" name="viewport">
  <title>three.js webgl - multiple cameras</title>
  <!-- https://stackoverflow.com/questions/14740076/one-scene-but-multiple-viewports-with-their-own-camera-three-js -->
  <!-- https://threejs.org/examples/webgl_multiple_views.html -->
  <link href="/favicon.ico" rel="icon" type="image/x-icon">
  <link href="/css/main.css" rel="stylesheet">
</head>
<body>

<div id="container"></div>
<div id="info"><a href="https://threejs.org" rel="noopener" target="_blank">three.js</a> - Only one canvas is used, so it's an efficient solution.</div>

<!-- Import maps polyfill -->
<!-- <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
	{
		"imports": {
			"three": "/build/three.module.js"
		}
	}
</script>

<script type="module">
  import * as THREE from "three";
  import Stats from "/jsm/libs/stats.module.js";

  let stats;
  let scene, renderer;
  let mouseX = 0, mouseY = 0;
  let windowWidth, windowHeight;

  let kimberly = "rgba(169, 129, 193, 1)"; // #a981c1
  kimberly = new THREE.Color(0.5, 0.5, 0.7);

  let neptune = "rgba(113, 180, 179, 1)"; // #71b4b3
  neptune = new THREE.Color(0.5, 0.7, 0.7);

  let oldRose = "rgba(187, 125, 127, 1)"; // #bb7d7f
  oldRose = new THREE.Color(0.7, 0.5, 0.5);

  let cameras = [
    {
      left: 0,
      bottom: 0,
      width: 0.5,
      height: 1.0,
      background: kimberly,
      eye: [0, 300, 1800], // camera position
      up: [0, 1, 0], // wtf is this?
      fov: 30, // the lower the #, the closer it is.
      updateCamera(camera, scene, mouseX) {
        camera.position.x += mouseX * 0.05; // x +=
        camera.position.x = Math.max(Math.min(camera.position.x, 2000), -2000);
        camera.lookAt(scene.position); // scene.position
      }
    },
    {
      left: 0.5,
      bottom: 0,
      width: 0.5,
      height: 0.5,
      background: oldRose,
      eye: [0, 1800, 0],
      up: [0, 0, 1],
      fov: 45,
      updateCamera(camera, scene, mouseX) {
        camera.position.x -= mouseX * 0.05; // x -+
        camera.position.x = Math.max(Math.min(camera.position.x, 2000), -2000);
        camera.lookAt(camera.position.clone().setY(0));
      }
    },
    {
      left: 0.5,
      bottom: 0.5,
      width: 0.5,
      height: 0.5,
      background: neptune,
      eye: [1400, 800, 1400],
      up: [0, 1, 0],
      fov: 60, // the higher the #, the further away it is.
      updateCamera(camera, scene, mouseX) {
        camera.position.y -= mouseX * 0.05; // y -=
        camera.position.y = Math.max(Math.min(camera.position.y, 1600), -1600);
        camera.lookAt(scene.position); // scene.position
      }
    }
  ];

  init();
  animate();

  function init() {
    let container = document.getElementById("container");

    // "Cameras", "views", whatever you wanna call it.
    for (let ii = 0; ii < cameras.length; ++ii) {
      let view = cameras[ii];
      let camera = new THREE.PerspectiveCamera(view.fov, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.fromArray(view.eye);
      camera.up.fromArray(view.up);
      view.camera = camera;
      // console.log("camera", JSON.stringify(view));
    }

    scene = new THREE.Scene();

    let light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0, 0, 1);
    scene.add(light);

    let radius = 200;

    let geometry1 = new THREE.IcosahedronGeometry(radius, 1);

    let count = geometry1.attributes.position.count;
    geometry1.setAttribute("color", new THREE.BufferAttribute(new Float32Array(count * 3), 3));

    let geometry2 = geometry1.clone();
    let geometry3 = geometry1.clone();

    let material = new THREE.MeshBasicMaterial({
      color: 0x00ff00,
      wireframe: true
    });

    let mesh = new THREE.Mesh(geometry1, material);
    let wireframe = new THREE.Mesh(geometry1, material);
    mesh.add(wireframe);
    mesh.position.x = -400;
    mesh.rotation.x = -1.87;
    scene.add(mesh);

    mesh = new THREE.Mesh(geometry2, material);
    wireframe = new THREE.Mesh(geometry2, material);
    mesh.add(wireframe);
    mesh.position.x = 400;
    scene.add(mesh);

    mesh = new THREE.Mesh(geometry3, material);
    wireframe = new THREE.Mesh(geometry3, material);
    mesh.add(wireframe);
    scene.add(mesh);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    stats = new Stats();
    container.appendChild(stats.dom);

    document.addEventListener("mousemove", onDocumentMouseMove);
  }

  function onDocumentMouseMove(event) {
    mouseX = event.clientX - windowWidth / 2;
    mouseY = event.clientY - windowHeight / 2;
    // Whatever happened to (updatePointer)...?
    // const rect = _domElement.getBoundingClientRect();
    // _pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1;
    // _pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1;
  }

  function updateSize() {
    if (windowWidth !== window.innerWidth || windowHeight !== window.innerHeight) {
      windowWidth = window.innerWidth;
      windowHeight = window.innerHeight;
      renderer.setSize(windowWidth, windowHeight);
    }
  }

  function animate() {
    render();
    stats.update();

    requestAnimationFrame(animate);
  }

  function render() {
    updateSize();

    for (let ii = 0; ii < cameras.length; ++ii) {
      let view = cameras[ii];
      let camera = view.camera;

      view.updateCamera(camera, scene, mouseX, mouseY);

      let left = Math.floor(windowWidth * view.left);
      let bottom = Math.floor(windowHeight * view.bottom);
      let width = Math.floor(windowWidth * view.width);
      let height = Math.floor(windowHeight * view.height);

      renderer.setViewport(left, bottom, width, height);
      renderer.setScissor(left, bottom, width, height);
      // The Scissor Test discards Fragments that fall outside of a certain rectangular portion of the screen.
      // glScissor() defines a screen space rectangle beyond which nothing is drawn (if the scissor test is enabled).
      renderer.setScissorTest(true);
      renderer.setClearColor(view.background);

      camera.aspect = width / height;
      camera.updateProjectionMatrix();

      renderer.render(scene, camera);
    }
  }
</script>
</body>
</html>
