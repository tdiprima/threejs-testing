<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Three.js - Multiple Views</title>
  <!-- https://ryansblog.xyz/post/e2610e26-ffea-4594-97e2-703cef49d614 -->
  <!-- Nothing can be shared across contexts, and things have to be loaded twice, though. -->
  <!-- It gets worse as there are more canvases. -->
  <!-- https://r105.threejsfundamentals.org/threejs/lessons/threejs-multiple-scenes.html -->
  <!-- The solution is one canvas that fills the viewport in the background and some other element to represent each "virtual" canvas. -->
  <link href="/favicon.ico" rel="icon" type="image/x-icon">
  <style>
    :root {
      color-scheme: light dark;
    }
  </style>
</head>
<body>

<div id="info">
  <ul>
    <li>one scene</li>
    <li>two renderers: There will be two canvas and two div elements</li>
    <li>two cameras: Each render has its own camera.</li>
    <li>two controls</li>
  </ul>
</div>

<div id="demo_multi_divs">
  <div style="height: 5vh"></div>
  <div id="demo_multi_divs_display_1" style="margin:auto;text-align:center;"></div>
  <div style="height: 5vh"></div>
  <div id="demo_multi_divs_display_2" style="margin:auto;text-align:center;"></div>
</div>

<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
	{
		"imports": {
			"three": "/build/three.module.js",
			"three/addons/": "/jsm/"
		}
	}

</script>
<script type="module">
  import * as THREE from "/build/three.module.js";
  import {OrbitControls} from "/jsm/controls/OrbitControls.js";

  function rand(min, max) {
    if (max === undefined) {
      max = min;
      min = 0;
    }
    return min + (max - min) * Math.random();
  }

  function randomColor() {
    return `hsl(${rand(360) | 0}, ${rand(50, 100) | 0}%, 50%)`;
  }

  function createDefaultRender(elementId) {
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth / 4, window.innerHeight / 4);
    document.getElementById(elementId).appendChild(renderer.domElement);
    renderer.domElement.style.border = "1px solid orange";
    renderer.domElement.style.margin = "auto";
    return renderer;
  }

  function createDefaultCamera() {
    let fov = 75;
    let aspect = window.innerWidth / window.innerHeight;
    let near = 0.1;
    let far = 200;
    return new THREE.PerspectiveCamera(fov, aspect, near, far);
  }

  function main() {
    let renderer1 = createDefaultRender("demo_multi_divs_display_1");
    let camera1 = createDefaultCamera();
    camera1.position.z = 30;

    let renderer2 = createDefaultRender("demo_multi_divs_display_2");
    let camera2 = createDefaultCamera();
    camera2.position.z = 30;

    // Create an orbit control.
    let controls1 = new OrbitControls(camera1, renderer1.domElement);
    let controls2 = new OrbitControls(camera2, renderer2.domElement);

    // Create the scene
    let scene = new THREE.Scene();
    scene.background = new THREE.Color('white');

    // Create a camera pole
    let cameraPole1 = new THREE.Object3D();
    let cameraPole2 = new THREE.Object3D();

    scene.add(cameraPole1);
    scene.add(cameraPole2);

    cameraPole1.add(camera1);
    cameraPole2.add(camera2);

    // Add a light source to the camera
    let color = 0xFFFFFF;
    let intensity = 1;
    let light1 = new THREE.DirectionalLight(color, intensity);
    let light2 = new THREE.DirectionalLight(color, intensity);
    light1.position.set(0, 0, 0);
    light2.position.set(0, 0, 0);
    camera1.add(light1);
    camera2.add(light2);

    // Define the geometry of the displayed boxes.
    let boxWidth = 1;
    let boxHeight = 1;
    let boxDepth = 1;
    let geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

    function makeInstance(geometry, color) {
      let material = new THREE.MeshPhongMaterial({color});

      let cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      cube.position.set(rand(-20, 20), rand(-20, 20), rand(-20, 20));
      cube.rotation.set(rand(Math.PI), rand(Math.PI), 0);
      cube.scale.set(rand(3, 6), rand(3, 6), rand(3, 6));

      return cube;
    }

    // Create a list of cubes
    let N = 10;
    let cubes = [];

    for (let i = 0; i < N; ++i) {
      makeInstance(geometry, randomColor());
    }

    function updateAll(scene, renderer, camera, controls) {
      let canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();

      controls.update();
      renderer.render(scene, camera);
    }

    function render(time) {
      time *= 0.001;

      // Rotate the camera pole. Recall that the camera is attached to the camera pole and there is a light source
      // attached to the camera.
      cameraPole1.rotation.y = time * 0.5;
      cameraPole2.rotation.y = time * -0.5;

      cubes.forEach((cube, ndx) => {
        let speed = 1 + ndx * .1;
        let rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      updateAll(scene, renderer1, camera1, controls1);
      updateAll(scene, renderer2, camera2, controls2);
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>

</body>
</html>
