<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Sun Earth Moon</title>
  <!-- http://127.0.0.1:5500/manual/#en/scenegraph -->
  <!-- We're using sun, earth, moon as a demonstration of how to use a scene graph. -->
  <link rel="stylesheet" href="/css/manual.css">
</head>
<body>

<canvas id="c"></canvas>

<script  type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";

  function main() {
    let canvas = document.querySelector("#c");
    let renderer = new THREE.WebGLRenderer({ canvas });

    let fov = 40;
    let aspect = 2; // the canvas default
    let near = 0.1;
    let far = 1000;

    // Put the camera directly above the origin looking down.
    let camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(0, 50, 0);
    // Tell the camera which way the top of the camera is facing.
    camera.up.set(0, 0, 1); // (which way is "up")
    camera.lookAt(0, 0, 0);

    let scene = new THREE.Scene();

    {
      let color = 0xffffff;
      let intensity = 3;
      let light = new THREE.PointLight(color, intensity);
      scene.add(light);
    }

    // Of course the real sun, earth, and moon use physics but for our purposes we'll fake it with a scene graph.

    // an array of objects whose rotation to update
    let objects = [];

    // use just one sphere for everything
    let radius = 1;
    let widthSegments = 6;
    let heightSegments = 6;
    let sphereGeometry = new THREE.SphereGeometry(
      radius,
      widthSegments,
      heightSegments
    );

    // SUN
    // A phong material's emissive property is the color that will be drawn with no light hitting the surface.
    let sunMaterial = new THREE.MeshPhongMaterial({ emissive: 0xffff00 });
    let sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial);
    sunMesh.scale.set(5, 5, 5); // make the sun large
    scene.add(sunMesh);
    objects.push(sunMesh);

    // EARTH
    // Give it a small amount of emissive blue so that it will show up against our black background.
    let earthMaterial = new THREE.MeshPhongMaterial({color: 0x2233FF, emissive: 0x112244});
    let earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial);
    // Position it 10 units to the left of the sun
    earthMesh.position.x = 10;
    scene.add(earthMesh);
    objects.push(earthMesh);

    // Put a single point light in the center of the scene.
    // {
    //   let color = 0xffffff;
    //   let intensity = 3;
    //   let light = new THREE.PointLight(color, intensity);
    //   scene.add(light);
    // }

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      let width = canvas.clientWidth;
      let height = canvas.clientHeight;
      let needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      // Rotate all objects in our objects array
      objects.forEach(obj => {
        obj.rotation.y = time;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  }

  main();
</script>
</body>
</html>
