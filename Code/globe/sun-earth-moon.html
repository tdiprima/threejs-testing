<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Sun Earth Moon</title>
  <!-- http://127.0.0.1:5500/manual/#en/scenegraph -->
  <!-- We're using sun, earth, moon as a demonstration of how to use a scene graph. -->
  <link href="/css/manual.css" rel="stylesheet">
  <script src="../misc/dumpObject.js"></script>
</head>
<body>

<canvas id="c"></canvas>

<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}
</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";
  import {OrbitControls} from "three/addons/controls/OrbitControls.js";

  function main() {
    let canvas = document.querySelector("#c");
    let renderer = new THREE.WebGLRenderer({canvas});

    let fov = 40;
    let aspect = 2; // the canvas default
    let near = 0.1;
    let far = 1000;

    // Put the camera directly above the origin looking down.
    let camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.set(0, 50, 0);
    // Tell the camera which way the top of the camera is facing.
    camera.up.set(0, 0, 1); // (which way is "up")
    camera.lookAt(0, 0, 0);

    let controls = new OrbitControls(camera, canvas);

    let scene = new THREE.Scene();

    {
      // Put a single point light in the center of the scene.
      let color = 0xffffff;
      let intensity = 3;
      let light = new THREE.PointLight(color, intensity);
      scene.add(light);
    }

    // Of course the real sun, earth, and moon use physics but for our purposes we'll fake it with a scene graph.

    // an array of objects whose rotation to update
    let objects = [];

    // use just one sphere for everything
    let radius = 1;
    let widthSegments = 6;
    let heightSegments = 6;
    let sphereGeometry = new THREE.SphereGeometry(
      radius,
      widthSegments,
      heightSegments
    );

    // SOLAR SYSTEM
    const solarSystem = new THREE.Object3D();
    solarSystem.name = "Solar System";
    scene.add(solarSystem);
    objects.push(solarSystem);

    // SUN
    // A phong material's emissive property is the color that will be drawn with no light hitting the surface.
    let sunMaterial = new THREE.MeshPhongMaterial({emissive: 0xffff00});
    let sunMesh = new THREE.Mesh(sphereGeometry, sunMaterial);
    sunMesh.name = "Sun";
    sunMesh.scale.set(5, 5, 5); // make the sun large
    solarSystem.add(sunMesh);
    objects.push(sunMesh);

    // EARTH ORBIT
    const earthOrbit = new THREE.Object3D();
    earthOrbit.name = "Earth Orbit";
    // Position it 10 units to the left of the sun
    earthOrbit.position.x = 10;
    solarSystem.add(earthOrbit);
    objects.push(earthOrbit);

    // EARTH
    // Give it a small amount of emissive blue so that it will show up against our black background.
    let earthMaterial = new THREE.MeshPhongMaterial({color: 0x2233ff, emissive: 0x112244});
    let earthMesh = new THREE.Mesh(sphereGeometry, earthMaterial);
    earthMesh.name = "Earth";
    earthOrbit.add(earthMesh);
    objects.push(earthMesh);

    // MOON ORBIT
    let moonOrbit = new THREE.Object3D();
    moonOrbit.name = "Moon Orbit";
    // Position it 2 units to the left of the Earth
    moonOrbit.position.x = 2;
    earthOrbit.add(moonOrbit);
    objects.push(moonOrbit); // (He didn't push the moon orbit; yet, he pushed the Earth orbit?)
    // What if I don't push either of them; just the earth and moon?
    // They seem to spin slower if I do that.

    // MOON
    let moonMaterial = new THREE.MeshPhongMaterial({color: 0x888888, emissive: 0x222222});
    let moonMesh = new THREE.Mesh(sphereGeometry, moonMaterial);
    moonMesh.name = "Moon";
    moonMesh.scale.set(.5, .5, .5);
    moonOrbit.add(moonMesh);
    objects.push(moonMesh);

    console.log(dumpObject(solarSystem).join('\n'));
    // console.log(dumpObject(scene).join('\n'));

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      let width = canvas.clientWidth;
      let height = canvas.clientHeight;
      let needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      // Rotate all objects in our objects array
      objects.forEach(obj => {
        obj.rotation.y = time;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>
</body>
</html>
