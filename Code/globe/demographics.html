<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Basic Demographic Characteristics</title>
  <!-- https://threejs.org/manual/#en/optimize-lots-of-objects-animated -->
  <!-- Using morphtargets is a common technique to move lots of objects. -->
  <style>
    html, body {
      height: 100%;
      margin: 0;
      color: white;
    }

    #c {
      display: block;
      width: 100%;
      height: 100%;
    }

    #ui {
      position: absolute;
      top: 1em;
      left: 1em;
    }

    #ui > div {
      font-size: 20pt;
      display: inline-block;
      padding: 1em;
    }

    #ui > div.selected {
      color: red;
    }

    @media (max-width: 700px) {
      #ui > div {
        display: block;
        padding: .25em;
      }
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div id="ui"></div>

<script  type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";
  import * as BufferGeometryUtils from "three/addons/utils/BufferGeometryUtils.js";
  import {OrbitControls} from "three/addons/controls/OrbitControls.js";
  import {TWEEN} from "three/addons/libs/tween.module.min.js";

  const womenData = "./data/gpw_v4_basic_demographic_characteristics_rev10_a000_014ft_2010_cntm_1_deg.asc";
  const menData = "./data/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc";

  /**
   * We're supposed to call TWEEN.update every frame inside our render loop, but
   * we are rendering on demand. Tween is designed for continuous rendering.
   * So we'll make a TweenManager to help.
   * We'll use it to create the Tweens and track them.
   * It will have an update method that will return true if we need to call it again,
   * and false if all the animations are finished.
   */
  class TweenManger {
    constructor() {
      this.numTweensRunning = 0;
    }

    _handleComplete() {
      --this.numTweensRunning;
      console.assert(this.numTweensRunning >= 0); /* eslint no-console: off */
    }

    /**
     * Create a Tween
     * @param targetObject
     * @return {*}
     */
    createTween(targetObject) {
      let self = this;
      ++this.numTweensRunning;
      let userCompleteFn = () => {
      };

      // create a new tween and install our own onComplete callback
      let tween = new TWEEN.Tween(targetObject).onComplete(function (...args) {
        self._handleComplete();
        userCompleteFn.call(this, ...args);
      });

      // replace the tween's onComplete function with our own
      // so that we can call the user's callback if they supply one.
      tween.onComplete = fn => {
        userCompleteFn = fn;
        return tween;
      };
      return tween;
    }

    /**
     * true = call again
     * false = animations finished
     * @return {boolean}
     */
    update() {
      TWEEN.update();
      return this.numTweensRunning > 0;
    }
  }

  function main() {
    let canvas = document.querySelector("#c");
    let renderer = new THREE.WebGLRenderer({canvas});
    let tweenManager = new TweenManger();

    let fov = 60;
    let aspect = 2; // the canvas default
    let near = 0.1;
    let far = 10;
    let camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = 2.5;

    let controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 1.2;
    controls.maxDistance = 4;
    controls.update();

    let scene = new THREE.Scene();
    scene.background = new THREE.Color("black");

    {
      let loader = new THREE.TextureLoader();
      let texture = loader.load("./images/world.jpg", render);
      let geometry = new THREE.SphereGeometry(1, 64, 32);
      let material = new THREE.MeshBasicMaterial({map: texture});
      scene.add(new THREE.Mesh(geometry, material));
    }

    async function loadFile(url) {
      let req = await fetch(url);
      return req.text();
    }

    function parseData(text) {
      let data = [];
      let settings = {data};
      let max;
      let min;
      // split into lines
      text.split("\n").forEach(line => {
        // split the line by whitespace
        let parts = line.trim().split(/\s+/);
        if (parts.length === 2) {
          // only 2 parts, must be a key/value pair
          settings[parts[0]] = parseFloat(parts[1]);
        } else if (parts.length > 2) {
          // more than 2 parts, must be data
          let values = parts.map(v => {
            let value = parseFloat(v);
            if (value === settings.NODATA_value) {
              return undefined;
            }
            max = Math.max(max === undefined ? value : max, value);
            min = Math.min(min === undefined ? value : min, value);
            return value;
          });
          data.push(values);
        }
      });
      return Object.assign(settings, {min, max});
    }

    function dataMissingInAnySet(fileInfos, latNdx, lonNdx) {
      for (let fileInfo of fileInfos) {
        if (fileInfo.file.data[latNdx][lonNdx] === undefined) {
          return true;
        }
      }
      return false;
    }

    function makeBoxes(file, hueRange, fileInfos) {
      let {min, max, data} = file;
      let range = max - min;

      // these helpers will make it easy to position the boxes
      // We can rotate the lon helper on its Y axis to the longitude
      let lonHelper = new THREE.Object3D();
      scene.add(lonHelper);
      // We rotate the latHelper on its X axis to the latitude
      let latHelper = new THREE.Object3D();
      lonHelper.add(latHelper);
      // The position helper moves the object to the edge of the sphere
      let positionHelper = new THREE.Object3D();
      positionHelper.position.z = 1;
      latHelper.add(positionHelper);
      // Used to move the center of the cube so it scales from the position Z axis
      let originHelper = new THREE.Object3D();
      originHelper.position.z = 0.5;
      positionHelper.add(originHelper);

      let color = new THREE.Color();

      let lonFudge = Math.PI * 0.5;
      let latFudge = Math.PI * -0.135;
      let geometries = [];
      data.forEach((row, latNdx) => {
        row.forEach((value, lonNdx) => {
          if (dataMissingInAnySet(fileInfos, latNdx, lonNdx)) {
            return;
          }
          let amount = (value - min) / range;

          let boxWidth = 1;
          let boxHeight = 1;
          let boxDepth = 1;
          let geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

          // adjust the helpers to point to the latitude and longitude
          lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
          latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

          // use the world matrix of the origin helper to
          // position this geometry
          positionHelper.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
          originHelper.updateWorldMatrix(true, false);
          geometry.applyMatrix4(originHelper.matrixWorld);

          // compute a color
          let hue = THREE.MathUtils.lerp(...hueRange, amount);
          let saturation = 1;
          let lightness = THREE.MathUtils.lerp(0.4, 1.0, amount);
          color.setHSL(hue, saturation, lightness);
          // get the colors as an array of values from 0 to 255
          let rgb = color.toArray().map(v => v * 255);

          // make an array to store colors for each vertex
          let numVerts = geometry.getAttribute("position").count;
          let itemSize = 3; // r, g, b
          let colors = new Uint8Array(itemSize * numVerts);

          // copy the color into the colors array for each vertex
          colors.forEach((v, ndx) => {
            colors[ndx] = rgb[ndx % 3];
          });

          let normalized = true;
          let colorAttrib = new THREE.BufferAttribute(colors, itemSize, normalized);
          geometry.setAttribute("color", colorAttrib);

          geometries.push(geometry);
        });
      });

      return BufferGeometryUtils.mergeBufferGeometries(geometries, false);
    }

    async function loadData(info) {
      let text = await loadFile(info.url);
      info.file = parseData(text);
    }

    /**
     * Load all the files in fileInfos[].
     * When done, each object in fileInfos will have a file property with the loaded file.
     * name will be for a UI field.
     * hueRange will be used to choose a range of hues to map over.
     * @return {Promise<void>}
     */
    async function loadAll() {
      let fileInfos = [
        {
          name: "men",
          hueRange: [0.7, 0.3],
          url: menData
        },
        {
          name: "women",
          hueRange: [0.9, 1.1],
          url: womenData
        }
      ];

      await Promise.all(fileInfos.map(loadData));

      /**
       * Given a 2 dimensional array of arrays, generate a new 2 dimensional array of arrays.
       * Like the normal Array.map function, this function calls a function fn for each value in the array of arrays.
       * It passes it the value and both the row and column indices.
       * @param data
       * @param fn
       * @return {*}
       */
      function mapValues(data, fn) {
        return data.map((row, rowNdx) => {
          return row.map((value, colNdx) => {
            return fn(value, rowNdx, colNdx);
          });
        });
      }

      /**
       * Generate a new file that is a comparison between 2 files.
       * It uses mapValues to generate a new set of data that is a comparison based on the compareFn function passed in.
       * It also tracks the min and max comparison results.
       * Finally, it makes a new file with all the same properties as baseFile, except with a new min, max and data.
       * @param baseFile
       * @param otherFile
       * @param compareFn
       * @return {*&{min, data: *, max}}
       */
      function makeDiffFile(baseFile, otherFile, compareFn) {
        let min;
        let max;
        let baseData = baseFile.data;
        let otherData = otherFile.data;

        let data = mapValues(baseData, (base, rowNdx, colNdx) => {
          let other = otherData[rowNdx][colNdx];
          if (base === undefined || other === undefined) {
            return undefined;
          }
          let value = compareFn(base, other);
          min = Math.min(min === undefined ? value : min, value);
          max = Math.max(max === undefined ? value : max, value);
          return value;
        });

        // make a copy of baseFile and replace min, max, and data
        // with the new data
        return {...baseFile, min, max, data};
      }

      // Use the results of makeDiffFile to make 2 new sets of data
      {
        let menInfo = fileInfos[0];
        let womenInfo = fileInfos[1];
        let menFile = menInfo.file;
        let womenFile = womenInfo.file;

        function amountGreaterThan(a, b) {
          let result = Math.max(a - b, 0);
          let rawDifference = a - b;
          let percent = a / (a + b);
          return result;
          // return rawDifference;
          // return percent;
        }

        fileInfos.push({
          name: ">50%men",
          hueRange: [0.6, 1.1],
          file: makeDiffFile(menFile, womenFile, (men, women) => {
            return amountGreaterThan(men, women);
          }),
        });

        fileInfos.push({
          name: ">50% women",
          hueRange: [0.0, 0.4],
          file: makeDiffFile(womenFile, menFile, (women, men) => {
            return amountGreaterThan(women, men);
          }),
        });
      }

      // make geometry for each data set
      let geometries = fileInfos.map(info => {
        return makeBoxes(info.file, info.hueRange, fileInfos);
      });

      // use the first geometry as the base
      // and add all the geometries as morphtargets
      let baseGeometry = geometries[0];

      // Get a position attribute from each geometry and add it as a morphtarget to the base geometry for position.
      baseGeometry.morphAttributes.position = geometries.map((geometry, ndx) => {
        let attribute = geometry.getAttribute("position");
        let name = `target${ndx}`;
        attribute.name = name;
        return attribute;
      });

      baseGeometry.morphAttributes.color = geometries.map((geometry, ndx) => {
        let attribute = geometry.getAttribute("color");
        let name = `target${ndx}`;
        attribute.name = name;
        return attribute;
      });

      let material = new THREE.MeshBasicMaterial({
        vertexColors: true,
      });

      let mesh = new THREE.Mesh(baseGeometry, material);
      scene.add(mesh);

      /**
       * Go over each file and generate a set of merged boxes per set of data, and an element
       * which when hovered over, will show that set (selected set) and hide all others.
       * @param fileInfos
       * @param fileInfo
       */
      function showFileInfo(fileInfos, fileInfo) {
        let targets = {};

        // For the data set we want to see, we need to have an influence of 1.
        // For all the ones we don't want to see, to we need to have an influence of 0.
        fileInfos.forEach((info, i) => {
          let visible = fileInfo === info;
          info.elem.className = visible ? "selected" : "";
          targets[i] = visible ? 1 : 0;
        });

        // Create a Tween to animate the influences.
        let durationInMs = 1000;
        tweenManager
          .createTween(mesh.morphTargetInfluences)
          .to(targets, durationInMs)
          .start();
        requestRenderIfNotRequested();
      }

      let uiElem = document.querySelector("#ui");
      fileInfos.forEach(info => {
        let div = document.createElement("div");
        info.elem = div;
        div.textContent = info.name;
        uiElem.appendChild(div);

        function show() {
          showFileInfo(fileInfos, info);
        }

        div.addEventListener("mouseover", show);
        div.addEventListener("touchstart", show);
      });

      // show the first set of data
      showFileInfo(fileInfos, fileInfos[0]);
    }

    loadAll();

    function resizeRendererToDisplaySize(renderer) {
      let canvas = renderer.domElement;
      let width = canvas.clientWidth;
      let height = canvas.clientHeight;
      let needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    let renderRequested = false;

    function render() {
      renderRequested = undefined;

      if (resizeRendererToDisplaySize(renderer)) {
        let canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      // Update the tweens, and keep rendering if there are still animations running.
      if (tweenManager.update()) {
        requestRenderIfNotRequested();
      }

      controls.update();
      renderer.render(scene, camera);
    }

    render();

    function requestRenderIfNotRequested() {
      if (!renderRequested) {
        renderRequested = true;
        requestAnimationFrame(render);
      }
    }

    controls.addEventListener("change", requestRenderIfNotRequested);
    window.addEventListener("resize", requestRenderIfNotRequested);
  }

  main();
</script>
</body>
</html>
