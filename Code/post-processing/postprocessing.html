<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport">
  <title>Three.js - PostProcessing</title>
  <!-- https://web.archive.org/web/20220929122146/https://r105.threejsfundamentals.org/threejs/lessons/threejs-post-processing.html -->
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}
</script>

<script type="module">
  import * as THREE from "three";
  import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
  import { BloomPass } from "three/addons/postprocessing/BloomPass.js";
  import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
  import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
  import { GUI } from "three/addons/libs/lil-gui.module.min.js"; // dat.gui.min.js

  function main() {

    let colorShader, colorPass;
    let bloomPass, filmPass;

    const canvas = document.querySelector("#c");
    const renderer = new THREE.WebGLRenderer({ canvas });

    const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5);
    camera.position.z = 2;

    const scene = new THREE.Scene();

    {
      // ADD LIGHT
      const light = new THREE.DirectionalLight(0xffffff, 2);
      light.position.set(-1, 2, 4);
      scene.add(light);
    }

    {
      // LOAD MY IMAGE
      const loader = new THREE.TextureLoader();
      const planeGeom = new THREE.PlaneGeometry(10, 10);
      let mesh;

      // Get texture
      const tex = loader.load("simondev-dog.jpg", tex => {
        tex.needsUpdate = true;
        console.log("aspect", tex.image.height / tex.image.width);
        mesh.scale.set(1.0, tex.image.height / tex.image.width, 1.0);
      });

      // Set material texture
      const material = new THREE.MeshBasicMaterial({
        map: tex,
        side: THREE.DoubleSide
      });

      mesh = new THREE.Mesh(planeGeom, material);
      scene.add(mesh);
    }

    // 1. Create an EffectComposer
    const composer = new EffectComposer(renderer);

    // 2. Add a RenderPass that will render our scene with our camera into the first render target.
    composer.addPass(new RenderPass(scene, camera));

    // BLOOM PASS
    function bloom() {
      // 3. Add a BloomPass (sorta stacks blurrs)
      bloomPass = new BloomPass(
        1,    // strength
        25,   // kernel size
        4,    // sigma ?
        256  // blur render target resolution
      );
      composer.addPass(bloomPass);

      // 4. Add a FilmPass that draws noise and scan-lines on top of its input.
      filmPass = new FilmPass(
        0.35,   // noise intensity
        0.025,  // scanline intensity
        648,    // scanline count
        false  // grayscale
      );

      // 5. Tell it to render to the canvas (instead of the next render target)
      filmPass.renderToScreen = true;
      composer.addPass(filmPass);
    }

    // SHADERS
    function shaders() {
      colorShader = {
        uniforms: {
          tDiffuse: { value: null },
          color: { value: new THREE.Color(0x88CCFF) }
        },
        vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
      }
    `,
        fragmentShader: `
      uniform vec3 color;
      uniform sampler2D tDiffuse;
      varying vec2 vUv;
      void main() {
        vec4 previousPassColor = texture2D(tDiffuse, vUv);
        gl_FragColor = vec4(
            previousPassColor.rgb * color,
            previousPassColor.a);
      }
    `
      };

      colorPass = new ShaderPass(colorShader);
      colorPass.renderToScreen = true;
      composer.addPass(colorPass);
    }

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    const gui = new GUI();

    // TODO: switch bloom() and shaders()
    // shaders();
    bloom();

    // TODO: switch guiBloom() and guiShaders()
    // guiShaders();
    guiBloom();

    // To change effect parameters at runtime usually requires setting uniform values.
    function guiBloom() {
      // GUI - BloomPass
      {
        const folder = gui.addFolder("BloomPass");
        // this.copyUniforms[ "opacity" ].value = strength; therefore -
        // bloomPass.copyUniforms.opacity.value = someValue;
        folder.add(bloomPass.combineUniforms.strength, "value", 0, 2).name("strength");
        folder.open();
      }

      // GUI - FilmPass
      {
        const folder = gui.addFolder("FilmPass");
        // if ( grayscale !== undefined ) { this.uniforms.grayscale.value = grayscale };
        folder.add(filmPass.uniforms.grayscale, "value").name("grayscale");
        folder.add(filmPass.uniforms.nIntensity, "value", 0, 1).name("noise intensity");
        folder.add(filmPass.uniforms.sIntensity, "value", 0, 1).name("scanline intensity");
        folder.add(filmPass.uniforms.sCount, "value", 0, 1000).name("scanline count");
        folder.open();
      }
    }

    function guiShaders() {
      gui.add(colorPass.uniforms.color.value, "r", 0, 4).name("red");
      gui.add(colorPass.uniforms.color.value, "g", 0, 4).name("green");
      gui.add(colorPass.uniforms.color.value, "b", 0, 4).name("blue");
    }

    let then = 0;

    function render(now) {
      now *= 0.001;  // convert to seconds
      const deltaTime = now - then;
      then = now;

      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
        // 5. Tell the EffectComposer to match the size of the canvas.
        composer.setSize(canvas.width, canvas.height);
      }

      /*
      EffectComposer.render takes a deltaTime which is the time in seconds since the
      last frame was rendered. It passes this to the various effects in case any of them
      are animated. In this case the FilmPass is animated.
      */

      // 6. Use EffectComposer.render instead of WebGLRenderer.render
      composer.render(deltaTime);
      // renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>
</body>
</html>
