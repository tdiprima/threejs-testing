<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport">
	<title>Three.js - PostProcessing</title>
	<!-- https://web.archive.org/web/20220929122146/https://r105.threejsfundamentals.org/threejs/lessons/threejs-post-processing.html -->
	<style>
		html,
		body {
			height: 100%;
			margin: 0;
		}

		#c {
			width: 100%;
			height: 100%;
			display: block;
		}
	</style>
</head>
<body>
<canvas id="c"></canvas>

<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js",
    "three/addons/": "../../examples/jsm/"
  }
}
</script>

<script type="module">
	import * as THREE from 'three';
	import {EffectComposer} from 'three/addons/postprocessing/EffectComposer.js';
	import {RenderPass} from 'three/addons/postprocessing/RenderPass.js';
	import {BloomPass} from 'three/addons/postprocessing/BloomPass.js';
	import {FilmPass} from 'three/addons/postprocessing/FilmPass.js';

	function main() {
		const canvas = document.querySelector('#c');
		const renderer = new THREE.WebGLRenderer({canvas});

		const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5);
		camera.position.z = 2;

		const scene = new THREE.Scene();

		{
			// ADD LIGHT
			const light = new THREE.DirectionalLight(0xffffff, 2);
			light.position.set(-1, 2, 4);
			scene.add(light);
		}

        {
			// LOAD MY IMAGE
			const loader = new THREE.TextureLoader();
			const planeGeom = new THREE.PlaneGeometry(10, 10);
			let mesh;

			// Get texture
			const tex = loader.load("simondev-dog.jpg", tex => {
				tex.needsUpdate = true;
				console.log('aspect', tex.image.height / tex.image.width);
				mesh.scale.set(1.0, tex.image.height / tex.image.width, 1.0);
			});

			// Set material texture
			const material = new THREE.MeshBasicMaterial({
				map: tex,
				side: THREE.DoubleSide
			});

			mesh = new THREE.Mesh(planeGeom, material);
			scene.add(mesh);
		}

		// 1. Create an EffectComposer
		const composer = new EffectComposer(renderer);

		// 2. Add a RenderPass that will render our scene with our camera into the first render target.
		composer.addPass(new RenderPass(scene, camera));

		// 3. Add a BloomPass (sorta stacks blurrs)
		const bloomPass = new BloomPass(
			1,    // strength
			25,   // kernel size
			4,    // sigma ?
			256,  // blur render target resolution
		);
		// bloomPass.renderToScreen = true;
		composer.addPass(bloomPass);

		// 4. Add a FilmPass that draws noise and scan-lines on top of its input.
		const filmPass = new FilmPass(
			0.35,   // noise intensity
			0.025,  // scanline intensity
			648,    // scanline count
			false,  // grayscale
		);

		// 5. Tell it to render to the canvas (instead of the next render target)
		filmPass.renderToScreen = true;
		composer.addPass(filmPass);

		function resizeRendererToDisplaySize(renderer) {
			const canvas = renderer.domElement;
			const width = canvas.clientWidth;
			const height = canvas.clientHeight;
			const needResize = canvas.width !== width || canvas.height !== height;
			if (needResize) {
				renderer.setSize(width, height, false);
			}
			return needResize;
		}

		let then = 0;

		function render(now) {
			now *= 0.001;  // convert to seconds
			const deltaTime = now - then;
			then = now;

			if (resizeRendererToDisplaySize(renderer)) {
				const canvas = renderer.domElement;
				camera.aspect = canvas.clientWidth / canvas.clientHeight;
				camera.updateProjectionMatrix();
				// 5. Tell the EffectComposer to match the size of the canvas.
				composer.setSize(canvas.width, canvas.height);
			}

			/*
			EffectComposer.render takes a deltaTime which is the time in seconds since the
			last frame was rendered. It passes this to the various effects in case any of them
			are animated. In this case the FilmPass is animated.
			*/

			// 6. Use EffectComposer.render instead of WebGLRenderer.render
			composer.render(deltaTime);
			// renderer.render(scene, camera);

			requestAnimationFrame(render);
		}

		requestAnimationFrame(render);
	}

	main();
</script>
</body>
</html>
