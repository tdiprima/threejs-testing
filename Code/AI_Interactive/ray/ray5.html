<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Raycasting Example</title>
    <!-- TODO: raycaster.intersectPlane is not a function -->
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.131.2/build/three.min.js"></script>
    <script>
      // Set up the scene and camera
      let scene = new THREE.Scene();
      let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      let renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Set up the mouse vector
      let mouse = new THREE.Vector2();

      // Set up the line material and geometry
      let material = new THREE.LineBasicMaterial({ color: 0xff0000 });
      let geometry = new THREE.BufferGeometry();

      // Set up the arrays to hold the line data
      let positions = [];
      let colors = [];
      let color = new THREE.Color();

      // Set up the line object
      let line = new THREE.Line(geometry, material);
      scene.add(line);

      // Set up the mouse event listeners
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);

      function onMouseMove(event) {
        // Calculate the mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Use the camera to unproject the mouse coordinates into the scene
        let point = new THREE.Vector3(mouse.x, mouse.y, 0);
        point.unproject(camera);

        // Perform your own intersection test against the unprojected point
        // In this example, we're just testing against a plane at z=0
        let plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        let raycaster = new THREE.Raycaster(camera.position, point.sub(camera.position).normalize());
        let intersection = raycaster.intersectPlane(plane);
        if (intersection) {
          positions.push(intersection.point.x, intersection.point.y, intersection.point.z);
          color.setHex(Math.random() * 0xffffff);
          colors.push(color.r, color.g, color.b);
          line.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
          line.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }
      }

      function onMouseUp() {
        // Remove the mouse event listeners
        document.removeEventListener('mousemove', onMouseMove, false);
        document.removeEventListener('mouseup', onMouseUp, false);

        // Update the line material to show the colors
        material.vertexColors = THREE.VertexColors;

        // Tell the renderer to render the scene
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
