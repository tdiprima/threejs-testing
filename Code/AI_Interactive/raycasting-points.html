<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Raycasting Example</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <script>
    let styles = [
      "color: green",
      "background: yellow",
      "font-size: 30px",
      "border: 1px solid red",
      "text-shadow: 2px 2px black",
      "padding: 10px",
      "border-radius:5px"
    ].join(";");
  </script>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.131.2/build/three.min.js"></script>
<script>
  // Set up scene and camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Set up raycaster and mouse vector
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Set up line material and geometry
  const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
  const geometry = new THREE.BufferGeometry();

  // Set up arrays to hold line data
  const positions = [];
  const colors = [];
  const color = new THREE.Color();

  // Set up line object
  const line = new THREE.Line(geometry, material);
  scene.add(line);

  // Set up the mouse event listeners
  document.addEventListener("mousemove", onMouseMove, false);
  document.addEventListener("mouseup", onMouseUp, false);

  function onMouseMove(event) {
    // console.log("%conMouseMove", styles);

    // Calculate mouse position in normalized device coordinates
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Use raycaster to get intersection point with scene
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    if (intersects.length > 0) {
      const point = intersects[0].point;
      positions.push(point.x, point.y, point.z);
      color.setHex(Math.random() * 0xffffff);
      colors.push(color.r, color.g, color.b);
      line.geometry.addAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
      line.geometry.addAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
    }
  }

  function onMouseUp() {
    // console.log("%conMouseUp", styles);

    // Remove mouse event listeners
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);

    // Draw the final line
    line.geometry.setDrawRange(0, positions.length / 3);
    line.geometry.computeBoundingSphere();
  }

  // Render scene
  function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
  }

  render();
</script>
</body>
</html>
