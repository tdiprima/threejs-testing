<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Read float buffer</title>
  <!-- https://discourse.threejs.org/t/how-to-get-texture-color-at-intersection-with-raycast/38631/8 -->
</head>
<body>

<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}
</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<!-- Straight outta webgl_read_float_buffer.html -->
<script id="fragment_shader_screen" type="x-shader/x-fragment">
  varying vec2 vUv;
  uniform sampler2D tDiffuse;

  void main() {
    gl_FragColor = texture2D(tDiffuse, vUv);
  }
</script>

<script id="vertexShader" type="x-shader/x-vertex">
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
</script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  let width = window.innerWidth;
  let height = window.innerHeight;

  // Initialize renderer
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(width, height);
  renderer.autoClear = false; // clear
  document.body.appendChild(renderer.domElement);

  // Scene / Raycaster / Camera / Controls
  const scene = new THREE.Scene();

  const cameraRTT = new THREE.OrthographicCamera(
    window.innerWidth / -2,
    window.innerWidth / 2,
    window.innerHeight / 2,
    window.innerHeight / -2,
    -10000,
    10000
  );
  cameraRTT.position.z = 100;

  const sceneScreen = new THREE.Scene();

  const renderTargetTexture = new THREE.WebGLRenderTarget(
    window.innerWidth, // width
    window.innerHeight, // height
    {
      minFilter: THREE.LinearFilter, // takes the four closest pixels
      magFilter: THREE.NearestFilter, // uses the value of the closest pixel
      format: THREE.RGBAFormat, // reads the red, green, blue and alpha
      type: THREE.FloatType
    } // options
  );

  // It's using a custom shader to sample the texture at point of intersection.
  const materialScreen = new THREE.ShaderMaterial({
    uniforms: { tDiffuse: { value: renderTargetTexture.texture } },
    vertexShader: document.getElementById("vertexShader").textContent,
    fragmentShader: document.getElementById("fragment_shader_screen").textContent,
    depthWrite: false
  });

  const plane = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);

  const quad = new THREE.Mesh(plane, materialScreen);
  quad.position.z = -100;
  sceneScreen.add(quad);

  // ( origin, direction, near = 0, far = Infinity )
  const rayCaster = new THREE.Raycaster(undefined, undefined, 0, undefined);

  const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
  camera.position.copy(new THREE.Vector3(100, 100, 100));
  camera.lookAt(new THREE.Vector3(0, 0, 0));
  scene.add(camera);

  const controls = new OrbitControls(camera, renderer.domElement);

  // Global variables
  const mouse = new THREE.Vector2();
  let planeMesh;
  let textureData;

  const imgPath = "https://cdn.pixabay.com/photo/2022/05/23/13/16/bird-7216181_1280.jpg";

  // Load texture and initialize planeMesh, textureData and renderTargetTexture
  new THREE.TextureLoader().load(imgPath, texture => {
    textureData = texture;

    planeMesh = new THREE.Mesh(
      new THREE.PlaneGeometry(texture.image.width, texture.image.height),
      new THREE.MeshBasicMaterial({ map: texture })
    );

    scene.add(planeMesh);
  });

  resize();
  animate();

  function resize() {
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
  }

  function animate() {
    renderer.clear(); // clear
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
    controls.update();
  }

  // RESIZE
  window.addEventListener("resize", resize);

  // POINTER UP
  window.addEventListener("pointerup", event => {
    // To calculate pages scrolling coordinates:
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    mouse.x = ((event.clientX - renderer.domElement.offsetLeft + scrollLeft) / renderer.domElement.width) * 2 - 1;
    mouse.y = -((event.clientY - renderer.domElement.offsetTop + scrollTop) / renderer.domElement.height) * 2 + 1;

    rayCaster.setFromCamera(mouse, camera);

    const intersections = rayCaster.intersectObject(planeMesh);

    // Raycast to get U,V coordinates at point of intersection
    if (intersections.length > 0) {
      // Using renderer.domElement.width, instead of window.innerWidth
      mouse.x = parseInt(renderer.domElement.width / 2 + (mouse.x * renderer.domElement.width) / 2);
      mouse.y = parseInt(renderer.domElement.height / 2 + (mouse.y * renderer.domElement.height) / 2);

      renderer.clear(); // clear

      // Load Texture into buffer
      renderer.setRenderTarget(renderTargetTexture);
      renderer.clear();
      renderer.render(scene, camera); // See webgl_rtt.html, line 251.

      // Huh?
      renderer.setRenderTarget(null);
      renderer.render(sceneScreen, cameraRTT);

      const read = new Float32Array(4);

      // Read target pixels from target Texture
      renderer.readRenderTargetPixels(
        renderTargetTexture, // render target
        mouse.x, // x
        mouse.y, // y
        1, // width
        1, // height
        read // buffer (output that 1px color to "read")
      );

      const r = parseInt(read[0] * 255);
      const g = parseInt(read[1] * 255);
      const b = parseInt(read[2] * 255);

      console.log(`X:${mouse.x} Y:${mouse.y} RGB: [${r},${g},${b}] Color: %c     `, `background:rgb(${r},${g},${b});`);
    }
  });
</script>
</body>
</html>
