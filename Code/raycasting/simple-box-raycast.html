<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>BoxGeometry Raycasting Example</title>

  <!-- Use Raycaster object to check for intersections between ray and box. -->
  <!-- Basically, see if your pointer is over the box.  Duh. -->
  <!-- Add event listener for mouse movements, which updates the mouse position. -->

  <link rel="stylesheet" href="/css/main.css">
  <script src="/build/three.min.js"></script>
</head>
<body>
<script>
  let initColor = 0x00ffbe;
  let rollColor = 0xff0000;
  let sceneColor = 0x8973f8;

  let scene = new THREE.Scene();
  scene.background = new THREE.Color(sceneColor);

  let camera = new THREE.PerspectiveCamera(
    75, // field of view
    window.innerWidth / window.innerHeight, // aspect ratio
    0.1, // near clipping plane
    1000 // far clipping plane
  );
  camera.position.z = 5;

  let renderer = new THREE.WebGLRenderer();
  // renderer.setPixelRatio(window.devicePixelRatio); // not recommended
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // BOX
  let mesh = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 1.5, 1.5),
    new THREE.MeshBasicMaterial({ color: initColor })
  );
  // mesh.position, rotation, scale

  // PLANE
  // // let geometry = new THREE.PlaneGeometry( 14.5, 7.5 );
  // let geometry = new THREE.PlaneGeometry( 7.5, 7.5 );
  // let material = new THREE.MeshBasicMaterial( { color: initColor } );
  // let mesh = new THREE.Mesh( geometry, material );

  scene.add(mesh);

  let raycaster = new THREE.Raycaster();
  let mouse = new THREE.Vector2();

  renderer.domElement.addEventListener('mousemove', event => {
    // Calculate the mouse position normalized to the screen
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Update the raycaster with the mouse position
    raycaster.setFromCamera(mouse, camera);

    // Check for intersections between the raycaster and the mesh
    let intersects = raycaster.intersectObject(mesh);

    // If there is an intersection, change the mesh color
    if (intersects.length > 0) {
      mesh.material.color.set(rollColor);
      // Random color
      // mesh.material.color = new THREE.Color( 0xffffff * Math.random() );
    } else {
      mesh.material.color.set(initColor);
    }
  });

  window.addEventListener("resize", function () {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.render(scene, camera);
  });

  (function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
  })();
</script>
</body>
</html>
