<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Textures</title>
  <!-- http://127.0.0.1:5500/manual/#en/textures -->
  <!-- https://youtu.be/8jP4xpga6yY -->
  <!-- https://codepen.io/bradtraversy/pen/VOpZvp -->
  <link href="/css/manual.css" rel="stylesheet">
</head>
<body>

<canvas id="c"></canvas>

<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js"
  }
}</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";

  function main() {
    let canvas = document.querySelector("#c");
    let renderer = new THREE.WebGLRenderer({canvas});

    let camera = new THREE.PerspectiveCamera(
      75, // fov
      2, // aspect
      0.1, // near
      5 // far
    );
    camera.position.z = 2;

    let scene = new THREE.Scene();

    let geometry = new THREE.BoxGeometry(
      1, // boxWidth
      1, // boxHeight
      1 // boxDepth
    );

    let cubes = []; // just an array we can use to rotate the cubes
    let loader = new THREE.TextureLoader();

    let material = new THREE.MeshBasicMaterial({
      map: loader.load("/textures/wall.jpg"),
    });

    let cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    cubes.push(cube); // add to our list of cubes to rotate

    function resizeRendererToDisplaySize(renderer) {
      let canvas = renderer.domElement;
      let width = canvas.clientWidth;
      let height = canvas.clientHeight;
      let needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        let canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      cubes.forEach((cube, ndx) => {
        let speed = 0.2 + ndx * 0.1;
        let rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>
</body>
</html>
