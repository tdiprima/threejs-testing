<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Textures</title>
  <!-- https://threejs.org/manual/#en/textures -->
  <!-- textures take width * height * 4 * 1.33 bytes of memory. -->
  <!-- Small in file size = fast to download. Small in dimensions = takes less memory. -->
  <link href="/css/manual.css" rel="stylesheet">
</head>
<body>

<canvas id="c"></canvas>

<script type="importmap">{
  "imports": {
    "three": "/build/three.module.js",
    "three/addons/": "/jsm/"
  }
}</script>
<script async src="/es-module-shims-1.3.6/dist/es-module-shims.js"></script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  function main() {
    let scene = new THREE.Scene();

    let canvas = document.querySelector("#c");
    let renderer = new THREE.WebGLRenderer({canvas});

    let camera = new THREE.PerspectiveCamera(
      75, // fov
      2, // aspect
      0.1, // near
      5 // far
    );
    camera.position.z = 2;

    let controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0, 0);
    controls.update();

    let geometry = new THREE.BoxGeometry(
      1, // boxWidth
      1, // boxHeight
      1 // boxDepth
    );

    // TODO: Play with images :)
    let img = "/textures/wall.jpg";
    // let img = "/textures/cut-the-rope.jpg";
    // let img = "/textures/mip-low-res-enlarged.png";

    let cubes = []; // just an array we can use to rotate the cubes
    let loader = new THREE.TextureLoader();

    // let material = new THREE.MeshBasicMaterial({
    //   map: loader.load(img)
    // });
    // let cube = new THREE.Mesh(geometry, material);
    // scene.add(cube);
    // cubes.push(cube); // add to our list of cubes to rotate

    loader.load(img, texture => {
      let material = new THREE.MeshBasicMaterial({
        map: texture
      });
      let cube = new THREE.Mesh(geometry, material);
      scene.add(cube);
      cubes.push(cube); // add to our list of cubes to rotate
    });

    function resizeRendererToDisplaySize(renderer) {
      let canvas = renderer.domElement;
      let width = canvas.clientWidth;
      let height = canvas.clientHeight;
      let needResize = canvas.width !== width || canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render(time) {
      time *= 0.001;

      if (resizeRendererToDisplaySize(renderer)) {
        let canvas = renderer.domElement;
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      cubes.forEach((cube, ndx) => {
        let speed = 0.2 + ndx * 0.1;
        let rot = time * speed;
        cube.rotation.x = rot;
        cube.rotation.y = rot;
        // Rotate cube (Change values to change speed)
        // cube.rotation.x += 0.01;
        // cube.rotation.y += 0.01;
      });

      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  }

  main();
</script>
</body>
</html>
