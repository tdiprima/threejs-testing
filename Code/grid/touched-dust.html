<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>Checkerboard</title>
  <link href="/css/main.css" rel="stylesheet">
  <!--
    To create a checkerboard pattern where each square faces the camera, you can alternate the colors of the squares.
    I'll modify the previous code to create this pattern and ensure the grid is facing the camera.
  -->
</head>
<body>
<script src="/build/three.min.js"></script>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = 5;

  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Create Custom Grid
  // We'll create a grid of plane geometries, where each plane represents a square in the grid.
  const gridSize = 7; // Grid will be gridSize x gridSize
  const squareSize = 1; // Size of each square
  const grid = new THREE.Group(); // Group to hold the grid

  // Colors for the checkerboard pattern
  const color1 = new THREE.Color(0x000000); // Color for the first square
  const color2 = new THREE.Color(0xffffff); // Color for the alternate square

  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      const geometry = new THREE.PlaneGeometry(squareSize, squareSize);
      // Alternate colors
      const material = new THREE.MeshBasicMaterial({
        color: (i + j) % 2 === 0 ? color1 : color2,
        side: THREE.DoubleSide
      });
      const square = new THREE.Mesh(geometry, material);

      // Position each square
      square.position.x = i * squareSize - (gridSize * squareSize) / 2 + squareSize / 2;
      square.position.z = j * squareSize - (gridSize * squareSize) / 2 + squareSize / 2; // Use z instead of y

      square.rotation.x = -Math.PI / 2; // Rotate to lie flat, facing up

      square.userData = { row: i, column: j, isSelected: false }; // Optional: Store grid position and selection status

      grid.add(square);
    }
  }

  // Make sure the camera is looking directly at the grid
  camera.position.set(0, gridSize, gridSize);
  camera.lookAt(grid.position);

  scene.add(grid);

  // Implement Raycaster and Mouse Events
  // Initialize a raycaster and add mouse event listeners:
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  }

  function onMouseDown(event) {
    // Logic for coloring a square
    colorSquare();
  }

  document.addEventListener("mousemove", onMouseMove, false);
  document.addEventListener("mousedown", onMouseDown, false);

  // Coloring Squares
  // Add a function to color the squares:
  function colorSquare() {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(grid.children);

    if (intersects.length > 0) {
      const square = intersects[0].object;
      square.material.color.set(0xff0000); // Change color on click
    }
  }

  window.addEventListener("resize", function() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  (function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  })();
</script>
</body>
</html>
